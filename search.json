[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Effets d’une mesure de restriction des trajets aériens sur les émissions de Co2",
    "section": "",
    "text": "Niveau technique\nEnjeux\n\n\n\n\nDébutant\nSuivre les consignes, tester les exemples, reprendre et comprendre les corrections. Utiliser le fichier CSV mis à disposition si l'intéraction avec l'API est trop compliquée.\n\n\nIntermédiaire\nChercher à faire les exercices et ne regarder les aides que si nécessaire. Se documenter sur l'utilisation de l'API de manière autonome."
  },
  {
    "objectID": "index.html#récupérer-le-projet-squelette-avec-git",
    "href": "index.html#récupérer-le-projet-squelette-avec-git",
    "title": "Effets d’une mesure de restriction des trajets aériens sur les émissions de Co2",
    "section": "2.1 Récupérer le projet squelette avec Git ",
    "text": "2.1 Récupérer le projet squelette avec Git \nSi vous disposez d’un compte sur le SSP Cloud, la méthode recommandée pour lancer ce tutoriel est de cliquer sur le bouton suivant :\n\n\n\n\nSi vous utilisez effectivement ce lien de lancement rapide, vous pouvez sauter l’étape de récupération du modèle de projet avec Git, cela a été fait automatiquement lors de la création de votre environnement RStudio.\n\n\n\n\n\n\nRécupérer le projet si vous n’avez pas utilisé le bouton proposé\n\n\n\n\n\n\nInterface graphiqueDepuis le terminal\n\n\nLa fiche utilitR sur l’utilisation de Git explicite la démarche générale pour récupérer du code grâce à Git. Il est recommandé de lire celle-ci si vous n’êtes pas familier de Git.\nLes étapes suivantes permettront de récupérer le projet:\n\n1️⃣ En premier lieu, dans RStudio, créer un nouveau projet et sélectionner Version Control.\n\n\n\n2️⃣ Choisir Git, ce qui devrait ouvrir une fenêtre similaire à celle ci-dessous :\n\n\n\n3️⃣ Dans la fenêtre Repository URL, copier https://github.com/inseefrlab/funathon2024_sujet1.git laisser les valeurs par défaut qui viennent ensuite et créer le projet.\n\n\n\nAprès avoir ouvert un terminal dans RStudio, exécuter\ngit clone https://github.com/inseefrlab/funathon2024_sujet1.git\npuis, dans l’explorateur de fichiers (fenêtre en bas à droite), cliquer sur le fichier RTraffic.Rproj pour ouvrir le projet.\n\n\n\n\n\n\nLe projet récupéré comporte de nombreux fichiers. Nous allons progressivement les découvrir dans ce tutoriel."
  },
  {
    "objectID": "index.html#se-placer-dans-le-projet-rstudio-associé-au-sujet",
    "href": "index.html#se-placer-dans-le-projet-rstudio-associé-au-sujet",
    "title": "Effets d’une mesure de restriction des trajets aériens sur les émissions de Co2",
    "section": "2.2 Se placer dans le projet RStudio associé au sujet",
    "text": "2.2 Se placer dans le projet RStudio associé au sujet\n\n2.2.1 Principe\nA la racine du projet, on trouve notamment le fichier funathon-sujet1.Rproj. Il s’agit d’un fichier de projet RStudio. Lorsqu’on travaille sur du code R avec RStudio, il est généralement préférable de travailler dans le cadre d’un projet. Entre autres raisons, cela favorise la reproductibilité : lorsqu’on se situe dans un projet RStudio, tous les chemins peuvent être définis de manière relative (à la racine du projet) plutôt que de manière absolue (à la racine de la machine). Ainsi, le projet s’exécutera de la même manière qu’il soit exécuté depuis une machine Windows ou Linux par exemple, ou avec des noms d’utilisateur différents. Pour plus de détails sur les bénéfices d’utiliser les projets RStudio ou leur utilisation en pratique, n’hésitez pas à consulter la fiche UtilitR dédiée.\n\n\n2.2.2 Activer un projet RStudio\nPour activer le projet RStudio associé au sujet, deux possibilités :\n\ncliquer directement sur le fichier dans l’explorateur de fichiers (en bas à droite)\ncliquer sur File &gt; Open Project puis dérouler l’arborescence jusqu’à sélectrionner le fichier .Rproj\n\nSi cela a fonctionné, vous devriez voir le nom du projet (funathon2024_sujet1) dans le coin en haut à droite de RStudio."
  },
  {
    "objectID": "index.html#installer-les-packages-nécessaires-pour-ce-tutoriel",
    "href": "index.html#installer-les-packages-nécessaires-pour-ce-tutoriel",
    "title": "Effets d’une mesure de restriction des trajets aériens sur les émissions de Co2",
    "section": "2.3 Installer les packages nécessaires pour ce tutoriel",
    "text": "2.3 Installer les packages nécessaires pour ce tutoriel\n\n2.3.1 Principe\nPour progresser dans ce tutoriel, un certain nombre de packages doivent être installés. Sans eux, même avec le code de l’application, vous ne serez pas en mesure de reproduire celle-ci.\nLes bonnes pratiques pour la gestion de l’environnement suggèrent de lister l’intégralité des packages et leur versions associées ce que permet de faire automatiquement renv. Grâce à cette liste, d’autres personnes pourront reproduire l’application si elles disposent des mêmes inputs (le code, les données…).\nEn effet, il est important de voir l’application comme le résultat de la combinaison de plusieurs ingrédients. Dans notre cas, nous en avons trois :\n\nDu code R : celui-ci a été récupéré par le biais de Git via Github\nDes éléments de configuration :\n\nle fichier renv.lock (R) qui permettra de reconstruire notre environnement à l’identique grâce à des outils adaptés1\nle fichier secrets.yaml qui contiendra des informations pour pouvoir se connecter à l’API.\n\nDes données : nous évoquerons celles-ci lors de la prochaine partie.\n\n1 Ces fichiers ne sont pas générés manuellement. Ce sont des outils adaptés (renv pour R) qui font ce travail de versionnage de l’environnement.\n\n\nIllustration du principe de séparation du code, des données et de la configuration\n\n\nDe manière générale, c’est une bonne pratique de structurer son projet comme une combinaison de ces facteurs. Cela vous amènera à faire des projets plus reproductibles mais aussi à la structure plus lisible.\nPour les utilisateurs de R, la formation de l’Insee aux bonnes pratiques consacre une partie aux environnements reproductibles avec renv. N’hésitez pas à aller regarder la documentation de renv\n\n\n2.3.2 Créer l’environnement\nL’intérêt d’utiliser renv réside dans la simplicité de recréer l’environnement nécessaire au bon fonctionnement de l’application : il suffit de lancer la commande suivante dans la console de RStudio :\nrenv::restore()\nEnsuite, il est tout à fait possible d’installer des packages supplémentaires via install.packages. L’environnement proposé par notre fichier renv.lock constitue le minimum requis pour reproduire l’application, mais il n’est pas figé. Si vous ajoutez des packages utiles pour votre application, n’oubliez pas d’exécuter renv::snapshot() avant la mise en production pour mettre à jour le fichier renv.lock. Maintenant que nous disposons d’un environnement fonctionnel, nous pouvons avancer sur la conception du projet. La première étape consiste à explorer les jeux de données que nous utiliserons dans l’application."
  },
  {
    "objectID": "2-analyse.html",
    "href": "2-analyse.html",
    "title": "Exploration des données issues de l’API de TravelTime",
    "section": "",
    "text": "1 Récupération des coordonnées des villes françaises\nL’objectif de cette partie est de récupérer les coordonnées géographiques des gares françaises à partir d’une base de données disponible en accès ouvert sur data.gouv.fr.\n\n\n\n\n\n\nComment télécharger un CSV dans un programe R ?\n\n\n\nIl suffit de copier-coller le lien de téléchargement d’un fichier CSV dans la fonction read.csv ou read.csv2 (exemple : read.csv(\"lien_de_téléchargement\"))\n\n\n\n\n\n\n\n\n Exercice 2 : Travailler avec des données géographiques\n\n\n\n\n\n\nSur data.gouv.fr, chercher le jeu de données correspondant à la liste des gare.\nImporter le jeu de données au format csv dans votre console R, sans télécharger localement le fichier. Observer les données.\n\n\n\nCliquer pour voir la réponse\n# On définit l'URL des données\nSTATIONS_DATA_URL &lt;- \"https://www.data.gouv.fr/fr/datasets/r/d22ba593-90a4-4725-977c-095d1f654d28\"\n\nstations_data &lt;- read.csv2(STATIONS_DATA_URL)\n\n\n\n\nAfficher les données\n\n\n\n\nUtiliser cette base de données qui contient, entre autres, les coordonnées géographiques des gares françaises afin d’extraire un couple de coordonnées (latitude, longitude) à partir d’un nom de gare. Faire un test en affichant les coordonnées de la gare de Lille-Flandres.\n\n\n\nCliquer pour voir la réponse\nSTATION_NAME &lt;- \"Lille-Flandres\"\n\ncoords &lt;- stations_data |&gt;\n  dplyr::select(lng = x_wgs84, lat = y_wgs84, libelle) |&gt;\n  dplyr::filter(libelle == STATION_NAME) |&gt;\n  dplyr::summarise(lat = dplyr::first(as.numeric(lat)), lng = dplyr::first(as.numeric(lng))) |&gt;\n  unlist(use.names = FALSE)\n\n\n\nEncapsuler le code précédent dans une fonction renvoyant les coordonnées d’une gare à partir de la chaîne de caractère du nom de la gare. Faire un test en affichant les coordonnées de la gare de Toulouse-Matabiau.\n\n\n\n\n\n\n\nAvertissement\n\n\n\nDans le jeu de données des stations de France, le point géographique pour la gare de Strasbourg-Ville si situe au milieu des rails… point qui est considéré inatteignable pour l’API de TravelTime. Utiliser le point \\((48.584488, 7.735626)\\) pour cette gare, qui correspond à l’entrée de la gare.\n\n\n\n\nCliquer pour voir la réponse\nget_station_coordinates &lt;- function(station, data, verbose = TRUE) {\n  if (station != \"Strasbourg-Ville\") {\n    coords &lt;- data |&gt;\n      dplyr::select(lng = x_wgs84, lat = y_wgs84, libelle) |&gt;\n      dplyr::filter(libelle == station) |&gt;\n      dplyr::summarise(lat = dplyr::first(as.numeric(lat)), lng = dplyr::first(as.numeric(lng))) |&gt;\n      unlist(use.names = FALSE)\n  } else {\n    coords &lt;- c(48.584488, 7.735626)\n  }\n\n  # Si verbose est TRUE, on affiche les coordonnées\n  if (verbose) {\n    cat(sprintf(\"%s -&gt; (%f, %f)\\n\", station, coords[1], coords[2]))\n  }\n\n  return(coords)\n}\n\ntlse_coords &lt;- get_station_coordinates(\"Toulouse-Matabiau\", stations_data, verbose = TRUE)\n\n\n\n\n\n\n\n2 Obtention du temps de transport entre 2 villes\nL’objectif de cette partie est de récupérer le temps de transport entre deux gares à partir de leur nom en combinant la fonction get_travel_time_api_response() donnée dans la fonction get_travel_time_api_response() et la fonction get_station_coordinates().\n\n\n\n\n\n\n Exercice 3 : Calcul du temps de transport\n\n\n\n\n\n\nCréer une fonction qui prend en paramètres deux couples de coordonnées et qui renvoie un JSON (en chaine de caractère) destiné à l’API de routage. Utilisez ces paramètres par défaut dans votre corps de requête :\n\n\nLieu de départ : Variable (coords1)\nLieu d’arrivée : Variable (coords2)\nMode de transport : Transport public (bus, métro, tram, train)\nDate et heure : 2024-06-26 à 18h00 UTC\nFlexibilité : 12h00\nLe reste des paramètres par défaut\n\n\n\nCliquer pour voir la réponse\nget_routes_api_json &lt;- function(coords1, coords2) {\n  # On créé le JSON pour l'API de routage en se basant sur celui de la sous-partie \"Interaction avec l'API de routage de TravelTime\"\n  request_body &lt;- sprintf('{\n    \"locations\": [\n      {\n        \"id\": \"point-from\",\n        \"coords\": {\n          \"lat\": %f,\n          \"lng\": %f\n        }\n      },\n      {\n        \"id\": \"point-to-1\",\n        \"coords\": {\n          \"lat\": %f,\n          \"lng\": %f\n        }\n      }\n    ],\n    \"departure_searches\": [\n      {\n        \"id\": \"departure-search\",\n        \"transportation\": {\n          \"type\": \"public_transport\",\n          \"walking_time\": 900,\n          \"cycling_time_to_station\": 100,\n          \"parking_time\": 0,\n          \"boarding_time\": 0,\n          \"driving_time_to_station\": 1800,\n          \"pt_change_delay\": 0,\n          \"disable_border_crossing\": false\n        },\n        \"departure_location_id\": \"point-from\",\n        \"arrival_location_ids\": [\n          \"point-to-1\"\n        ],\n        \"departure_time\": \"2024-06-26T18:00:00.000Z\",\n        \"properties\": [\n          \"travel_time\",\n          \"route\"\n        ],\n        \"range\": {\n          \"enabled\": true,\n          \"max_results\": 5,\n          \"width\": 43200\n        }\n      }\n    ]\n  }', coords1[1], coords1[2], coords2[1], coords2[2])\n  return(request_body)\n}\n\n\n\nEn utilisant la fonction précédement écrite, créer une fonction qui prend en paramètre deux noms de gares et qui renvoie le temps (en heure) de transport du trajet le plus court entre ces 2 gares. Il faudra prendre soin de gérer le cas où aucun trajet n’est trouvé en renvoyant Inf.\n\n\n\nCliquer pour voir la réponse\nget_travel_time_between_stations &lt;- function(station1, station2, data, verbose = TRUE) {\n  # Si les stations sont identiques aucun trajet nécessaire\n  if (station1 == station2) {\n    return(NA)\n  }\n\n\n  # Récupérer les coordonnées pour les deux stations\n  coordinates &lt;- lapply(c(station1, station2), get_station_coordinates, data = data, verbose = FALSE)\n\n  # Générer le JSON pour l'API de routage\n  request_body &lt;- get_routes_api_json(coordinates[[1]], coordinates[[2]])\n\n  # Interroger l'API de routage\n  response &lt;- get_travel_time_api_response(ROUTES_API_URL, request_body)\n\n  # Gérer la limitation du taux d'API\n  if (response[[2]] == 429) {\n    if (verbose) cat(\"Trop de requêtes, attente d'une minute...\\n\")\n    Sys.sleep(60)\n    return(get_travel_time_between_stations(station1, station2, data, verbose))\n  }\n\n  # Vérifier l'existence d'un itinéraire valide\n  if (length(response[[1]]$results[[1]]$locations) == 0) {\n    travel_time &lt;- Inf\n  } else {\n    # Extraire les données de temps de trajet et trouver le temps de trajet minimum en heures\n    travel_times &lt;- sapply(response[[1]]$results[[1]]$locations[[1]]$properties, function(item) item$travel_time)\n    travel_time &lt;- min(travel_times) / 3600\n  }\n\n  # Afficher le temps de trajet si verbose\n  if (verbose) {\n    message_text &lt;- sprintf(\"%s -&gt; %s : %s heures\\n\", station1, station2, ifelse(is.infinite(travel_time), \"Aucun itinéraire trouvé\", round(travel_time, 2)))\n    cat(message_text)\n  }\n\n  return(travel_time)\n}\n\n\n\nTester votre fonction avec Paris-Montparnasse et Toulouse-Matabiau.\n\n\n\nCliquer pour voir la réponse\ntravel_time &lt;- get_travel_time_between_stations(\"Paris-Montparnasse\", \"Toulouse-Matabiau\", stations_data, verbose = TRUE)\n\n\n\nFaire une matrice temporelle des temps de trajet entre les gares des 10 plus grandes agglomérations françaises (on considerera que la matrice est symétrique pour la compléter plus rapidement). La liste des noms des gares principales (telle qu’écrite dans la base de données en opendata) des 10 plus grandes agglomérations françaises est la suivante : Paris-Nord, Lyon-Perrache, Marseille-St-Charles, Toulouse-Matabiau, Lille-Flandres, Bordeaux-St-Jean, Nice-Ville, Nantes, Strasbourg-Ville et Montpellier-St-Roch.\n\n\n\n\n\n\n\nL’API de routage de TravelTime a un quota de requêtes par minute\n\n\n\nSi la fonction get_travel_time_api_response() donnée dans la partie 1 renvoie le code 429, cela signifie que vous avez dépassé le quota de requêtes par minute. Dans ce cas, attendez une minute avec la fonction Sys.sleep(60) avant de relancer la fonction précédement écrite.\n\n\n\n\nCliquer pour voir la réponse\n# Define the stations\nSTATIONS &lt;- c(\"Paris-Nord\", \"Lyon-Perrache\", \"Marseille-St-Charles\", \"Toulouse-Matabiau\", \"Lille-Flandres\", \"Bordeaux-St-Jean\", \"Nice-Ville\", \"Nantes\", \"Strasbourg-Ville\", \"Montpellier-St-Roch\")\n\n# Initialisation de la matrice\ntime_matrix &lt;- matrix(NA, nrow = length(STATIONS), ncol = length(STATIONS), dimnames = list(STATIONS, STATIONS))\n\n# On remplit la matrice avec toutes les pairs possibles\ncombinations &lt;- combn(STATIONS, 2, simplify = FALSE)\nfor (pair in combinations) {\n  travel_time &lt;- get_travel_time_between_stations(pair[1], pair[2], stations_data, verbose = FALSE)\n  time_matrix[pair[1], pair[2]] &lt;- round(travel_time, 2)\n  time_matrix[pair[2], pair[1]] &lt;- round(travel_time, 2)\n}\n\n\n\n\nAfficher la matrice\n\n\n\n\nimport { button } from \"@jeremiak/download-data-button\"\ntransformData = (data) =&gt; {\n  return data.map(item =&gt; {\n    const { _row, ...rest } = item;\n    const newItem = { Gare: _row, ...rest };\n    return newItem;\n  });\n};\n\n// Transform the data\ntransformedData = transformData(transpose(data))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbutton(transformedData, \"time-matrix.csv\")\n\n\n\n\n\n\n\nCréer une liste avec les couples des gares reliées par un temps de trajet inférieur à 4h30\n\n\n\nCliquer pour voir la réponse\nTHRESHOLD &lt;- 4.5\n\n# On garde seulement la matrice triangulaire inférieur (car on la supposé symmétrique)\nlower_tri_matrix &lt;- lower.tri(time_matrix)\n\n# On extrait les indices où la condition n'est pas respectée\nunder_threshold_indices &lt;- which(time_matrix &lt; THRESHOLD & lower_tri_matrix, arr.ind = TRUE)\n\n# On crée une liste de paires qui remplissent les conditions\nunder_threshold_routes &lt;- mapply(function(i, j) c(STATIONS[i], STATIONS[j]),\n  i = under_threshold_indices[, 1],\n  j = under_threshold_indices[, 2],\n  SIMPLIFY = FALSE,\n  USE.NAMES = FALSE\n)\n\n\n\n\n\n\n\n3 Téléchargement et traitement des données de trafic aérien entre deux villes\nCette partie du sujet consiste à télécharger et traiter des données de trafic aérien entre deux aéroports en 2019 pour calculer les émissions de CO2 du trafic aérien entre les couples de villes/de gares identifiés précédemment et d’en déduire les émissions de CO2 approximatives évitées avec des mesures hypothétiques d’interdictions de liaisons aériennes.\n\n\n\n\n\n\n Exercice 4 : Analyse du trafic aérien\n\n\n\n\n\n\nSur data.gouv.fr, trouver le jeu de données correspondant au trafic aérien publié par la DGAC.\nImporter le jeu de données au format csv de l’année 2019 dans votre console R, sans télécharger localement le fichier. Observer les données.\n\n\n\nCliquer pour voir la réponse\n# On définit l'URL des données\nAIR_TRAFFIC_DATA_URL &lt;- \"https://www.data.gouv.fr/fr/datasets/r/0c0a451e-983b-4f06-9627-b5ff1bccd2fc\"\n\nair_traffic_df &lt;- read.csv2(AIR_TRAFFIC_DATA_URL)\n\n\n\n\nAfficher les données\n\n\n\n\n\n\n\n\n\nAttention aux données agrégées\n\n\n\nLe fichier Excel de documentation series-asp-dgac-liste-v20231211b.xls sur data.gouv.fr précise que les lignes aériennes de moins de 10 000 passagers équivalents pour un mois donné sont regroupées dans un groupement de lignes du mois associé, par exemple “ZZCC_MET_RAD” pour les liaisons métropolitaines radiales. Ainsi les données sur une ligne aérienne donnée ne sont pas toujours exhaustives.\n\n\n\nCréer une fonction qui renvoie le trafic total d’une liaison en 2019 en PKT (produit du nombre de passagers et de la distance parcourue) à partir des deux noms de villes (et non d’aéroport) en paramètre.\n\n\n\n\n\n\n\nAstuce\n\n\n\n\nUtiliser le fichier Excel de documentation disponible sur data.gouv.fr pour identifier les colonnes utiles.\nLes noms des principaux aéroports de métropole contiennent le nom de la ville qu’il dessert.\nN’oubliez pas de prendre en compte le trafic aérien dans les deux sens.\nParis qui possède 2 aéroports commerciaux.\n\n\n\n\n\nCliquer pour voir la réponse\nget_air_traffic_between_cities &lt;- function(city1, city2, data) {\n  # Calcul du trafic dans les deux sens city1 -&gt; city2 et city2 -&gt; city1\n  total_traffic &lt;- data |&gt;\n    dplyr::filter(\n      (grepl(city1, LSN_DEP_NOM, ignore.case = TRUE) & grepl(city2, LSN_ARR_NOM, ignore.case = TRUE)) |\n        (grepl(city2, LSN_DEP_NOM, ignore.case = TRUE) & grepl(city1, LSN_ARR_NOM, ignore.case = TRUE))\n    ) |&gt;\n    dplyr::summarise(traffic = sum(LSN_DIST * LSN_PAX_loc)) |&gt; # calcul du PKT\n    dplyr::pull(traffic)\n\n  return(as.numeric(total_traffic))\n}\n\n\n\nTester la fonction avec Paris et Toulouse\n\n\n\nCliquer pour voir la réponse\nget_air_traffic_between_cities(\"Paris\", \"Toulouse\", air_traffic_df)\n\n\n\nSommer le trafic aérien pour chaque couple de villes reliées par un temps de trajet inférieur à 4h30\n\n\n\n\n\n\n\nAstuce\n\n\n\nLes noms des principales gares de métropole contiennent le nom de la ville qu’il dessert.\n\n\n\n\nCliquer pour voir la réponse\n# Fonction pour extraire les noms des villes à partir des noms des gares\nextract_city_name &lt;- function(station) {\n  sapply(station, function(x) strsplit(x, \"-\")[[1]][1])\n}\n\n# Extraire les paires de villes\ncity_pairs &lt;- lapply(under_threshold_routes, extract_city_name)\n\nunder_threshold_air_traffic &lt;- 0\n\n# Calculer le trafic aérien pour chaque paire\nfor (pair in city_pairs) {\n  air_traffic &lt;- get_air_traffic_between_cities(pair[1], pair[2], air_traffic_df)\n  under_threshold_air_traffic &lt;- under_threshold_air_traffic + air_traffic\n}\n\n\n\nEn déduire les émissions de CO2 approximatives évitées que représente ce trafic avec une estimation des gCO2éq par PKT de statista\n\n\n\nCliquer pour voir la réponse\nGCO2_PER_PKT &lt;- 80\n\n# On estime les émissions de CO2 en tCO2éq\ncat(sprintf(\"En 2019, environ %.2f tCO2éq aurait pu être évités\", under_threshold_air_traffic * GCO2_PER_PKT / 1000000))"
  },
  {
    "objectID": "1-api.html",
    "href": "1-api.html",
    "title": "Interaction avec l’API de routage de TravelTime",
    "section": "",
    "text": "La première partie du sujet consiste à interroger basiquement l’API de routage de TravelTime qui permet obtenir des données de temps de trajet entre deux points définis par leurs coordoonées géographiques.\nNous allons tout d’abord présenter comment construire une requête pour communiquer avec l’API de TravelTime afin de récupérer les données de temps de trajet. Avant cela, il va falloir effectuer plusieurs étapes préliminaires.\n\n\n\n\n\n\nQu’est ce qu’une API ?\n\n\n\nUne API est une interface logicielle (Application Programming Interface) qui permet à des applications de communiquer entre elles. Ces interfaces utilisent en général des requêtes HTTP contenant des JSON pour envoyer et recevoir des données.\n\n\nTout d’abord, il est nécessaire de créer un compte sur TravelTime afin de pouvoir accéder à leur API grâce à un identifiant et un mot de passe. Si vous avez un compte Github, l’authentification via ce canal est plus simple. Autrement, il va falloir utiliser votre adresse email professionnelle et renseigner votre numéro de téléphone. Nous sommes conscient que cela peut constituer un frein pour certaines personnes, et si vous ne souhaitez pas vous inscrire sur cette API privée il sera tout de même possible de réaliser la visualisation des résultats grâce aux données issues de l’API mis à votre disposition.\n\n\n\n\n\n\nAvertissement\n\n\n\nLe mail de confirmation de l’API peut mettre plusieurs minutes avant d’arriver, notamment si vous êtes sur un poste avec un proxy et sécurisé.\n\n\nUne fois que votre compte est créé, lorsque vous vous dirigez vers l’onglet Dashboard vous devriez avoir accès à votre ID et votre clé pour communiquer avec l’API, nous allons les stocker dans une fichier .yaml Ces informations sont personnelles et ne doivent pas être partagées, et encore moins être mises sur Github.\n\n\n\n\n\n\nQu’est ce qu’un fichier yaml ?\n\n\n\nC’est un format de fichier simplifié qui permet de stocker des données structurées à la manière d’un fomart CSV, JSON ou XML. Il est souvent utilisé pour stocker des configurations de programme.\n\n\n\n\n\n\n\n\n Exercice 1 : Se familiariser avec l’API de TravelTime\n\n\n\n\n\n\nCréer un compte sur TravelTime et récupérer les identifiants, les stocker dans un fichier secrets.yaml comme ci-dessous :\n\n\nsecrets.yaml\n\ntravelTime:\n  X_API_ID: \"votre_id_api_ici\"\n  X_API_KEY: \"votre_clé_api_ici\"\n\nAfin de prévenir un malencontreux commit de ce fichier, le rajouter dans le .gitignore du projet afin qu’il ne soit pas poussé sur Github.\n\n\n.gitignore\n\n/.quarto/\n/_site/\n/site_libs/\n/*_cache/\n.Rproj.user\nsecrets.yaml\n\nOn va pouvoir tester l’API, mais avant toute chose, prendre le temps de jeter un coup d’oeil à la documentation de l’API (ici). Se rendre sur le playground de l’API pour se familiariser avec son fonctionnement.\n\nAfin de vérifier que nous arrivons à communiquer avec l’API, nous allons effectuer la même requête présentée dans le playground directement dans notre console R.\n\nGrâce au package yaml, importer le contenu du fichier secrets.yaml et stocker le contenu dans les variables X_API_ID et X_API_KEY.\n\n\n\nCliquer pour voir la réponse\nsecrets &lt;- yaml::read_yaml(\"secrets.yaml\")\nX_API_ID &lt;- secrets$travelTime$X_API_ID\nX_API_KEY &lt;- secrets$travelTime$X_API_KEY\n\n\n\nEn lisant la documentation, ou en observant bien le playgroud trouver le endpoint de l’API de routage. Il s’agit de l’URL via lequel nous allons communiquer avec l’API. Stocker la dans la variable ROUTES_API_URL.\n\n\n\nCliquer pour voir la réponse\nROUTES_API_URL &lt;- \"https://api.traveltimeapp.com/v4/routes\"\n\n\n\nCopier-coller la requête utilisée dans l’exemple du playground. Il s’agit du corps de la requête, généralement celui-ci est spécifié au format JSON.\n\n\n\nCliquer pour voir la réponse\nrequest_body &lt;- '\n{\n  \"locations\": [\n    {\n      \"id\": \"point-from\",\n      \"coords\": {\n        \"lat\": 51.5119637,\n        \"lng\": -0.1279543\n      }\n    },\n    {\n      \"id\": \"point-to-1\",\n      \"coords\": {\n        \"lat\": 51.5156177,\n        \"lng\": -0.0919983\n      }\n    }\n  ],\n  \"departure_searches\": [\n    {\n      \"id\": \"departure-search\",\n      \"transportation\": {\n        \"type\": \"public_transport\"\n      },\n      \"departure_location_id\": \"point-from\",\n      \"arrival_location_ids\": [\n        \"point-to-1\"\n      ],\n      \"departure_time\": \"2024-06-26T18:00:00.000Z\",\n      \"properties\": [\n        \"travel_time\",\n        \"route\"\n      ],\n      \"range\": {\n        \"enabled\": true,\n        \"max_results\": 5,\n        \"width\": 900\n      }\n    }\n  ]\n}'\n\n\n\nAvec le package httr, définir l’en-tête de la requête, celle-ci doit contenir l’ID et la clé afin que l’API puisse bien vous identifier et renvoyer une réponse.\n\n\n\nCliquer pour voir la réponse\nheaders &lt;- httr::add_headers(\n  \"Content-Type\" = \"application/json\",\n  \"X-Application-Id\" = X_API_ID,\n  \"X-Api-Key\" = X_API_KEY\n)\n\n\n\nIl est dès à présent possible d’envoyer une requête. On va utiliser ici la méthode POST, notamment car on a besoin d’une authentification. Pour aller un peu plus loin sur les différences entre les méthodes GET et POST, vous pouvez regarder ce post.\n\n\n\nCliquer pour voir la réponse\nresponse &lt;- httr::POST(ROUTES_API_URL, body = request_body, encode = \"json\", headers)\n\ncontent &lt;- httr::content(response)\n\n\n\nVérifier que la requête a bien été reçue et traitée par l’API en regardant le code de retour, celui-ci doit être égal à 200. Si c’est bien le cas, regarder la réponse de l’API, elle devrait être similaire à ce qui est affiché ci-dessous.\n\n\n\nCliquer pour voir la réponse\nif (httr::status_code(response) == 200) {\n  print(\"La requête a bien été traitée\")\n  content &lt;- httr::content(response, as = \"parsed\")\n  print(content)\n} else {\n  # Affichage d'un message d'erreur si le code de la réponse n'est pas 200\n  print(sprintf(\"Une erreur est survenue. Code de la réponse : %d\", httr::status_code(response)))\n}\n\n\n\nCréer une fonction get_travel_time_api_response() qui renvoie la réponse de l’API de TravelTime pour un endpoint et une requête donnés.\n\n\n\nCliquer pour voir la réponse\nget_travel_time_api_response &lt;- function(api_url, request_body) {\n  # On prépare les headers\n  headers &lt;- httr::add_headers(\n    \"Content-Type\" = \"application/json\",\n    \"X-Application-Id\" = X_API_ID,\n    \"X-Api-Key\" = X_API_KEY\n  )\n  ## On envoie la requête avec les headers spécifiés\n  response &lt;- httr::POST(api_url, body = request_body, encode = \"json\", headers)\n\n  # On vérifie s'il y a eu une erreur\n  if (!httr::http_error(response)) {\n    return(list(\n      \"Content\" = httr::content(response, as = \"parsed\"),\n      \"Status_code\" = httr::status_code(response)\n    ))\n  } else {\n    # On affiche une message d'avertissement lorsque la requête n'a rien renvoyé\n    warning(\"Failed to retrieve data: \", httr::http_status(response)$message)\n    return(list(\n      \"Content\" = NA,\n      \"Status_code\" = httr::status_code(response)\n    ))\n  }\n}\n\n\n\nVérifier que votre fonction marche bien en utilisant la même requête que lors de la question 8 et comparez les réponses.\n\n\n\nCliquer pour voir la réponse\nresponse_from_function &lt;- get_travel_time_api_response(ROUTES_API_URL, request_body)\n\n\n\nExplorer attentivement la réponse avec la fonction View puis affecter la liste des descriptions des itinéraires trouvés à une variable list_itinerary (liste nommée properties dans le JSON).\n\n\n\nCliquer pour voir la réponse\nlist_itinerary &lt;- response_from_function[[1]]$results[[1]]$locations[[1]]$properties\nprint(list_itinerary)"
  },
  {
    "objectID": "3-dataviz.html",
    "href": "3-dataviz.html",
    "title": "Datavisualisation des données sur une carte avec le package leaflet",
    "section": "",
    "text": "Cette dernière partie du sujet consiste à visualiser les émissions de CO2 précédemment calculées sur une carte interactive avec le package leaflet et des fonds de carte de Stadia Maps afin d’identifier visuellement les liaisons aériennes les plus émissives.\n\n\n\n\n\n\n Exercice 5 : Visualiser des données géographiques\n\n\n\n\n\n\nDe la même manière que pour TravelTime, il est nécessaire de se créer un compte sur Stadia Maps afin d’avoir accès à leur API.\nUne fois que votre compte est créé et vérifié votre compte, créez une property et nommez la “funathon”.\nCliquer sur Add API Key, puis la copier dans le fichier secrets.yaml créé dans lors de l’exercice 1.\n\n\nsecrets.yaml\n\nstadiaMaps:\n  API_KEY: \"votre_clé_api_ici\"\n\nL’API de Stadia Maps permet de récupérer des fonds de carte avec des styles différents en fonction des besoins et préféreces. En s’aidant de la documentation de l’API, reconstituer l’URL qui récupère une tuile Stadia Maps pour un style donné.\n\n\n\n\n\n\n\nNote\n\n\n\nA la différence de l’API de routage de TravelTime, l’API de Stadia Maps pour obtenir un fond de carte est plus simple d’utilisation puisque la requête HTTP se fait simplement via un lien HTML (sans JSON). En effet, nous utilisons la méthode GET et l’authentification se fait directement via l’URL (ce qui n’est pas optimal en terme de sécurité).\n\n\n\n\nAfficher l’aide\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nPour récupérer le format de l’URL vous pouvez regarder ces pages de la documentation :\n\nRaster Map Tiles\nMap Styles\n\n\n\n\n\n\nCliquer pour voir la réponse\nsecrets &lt;- yaml::read_yaml(\"secrets.yaml\")\nSTADIA_MAPS_API_KEY &lt;- secrets$stadiaMaps$API_KEY\n\nSTYLE &lt;- \"outdoors\"\n\nTILES_URL &lt;- sprintf(\"https://tiles.stadiamaps.com/tiles/%s/{z}/{x}/{y}{r}.png?api_key=%s\", STYLE, STADIA_MAPS_API_KEY)\n\n\n\nCréer un dataframe avec tous les éléments pour cartographier les émissions sur les lignes repérées (les noms, les latitudes et les longitudes des villes de départ et d’arrivée, et les émissions de CO2 des lignes associées)\n\n\n\nCliquer pour voir la réponse\nGCO2_PER_PKT &lt;- 80\n\nemission_by_route_list &lt;- list()\n\nfor (pair in city_pairs) {\n  coordinates &lt;- lapply(names(pair), get_station_coordinates, data = stations_data, verbose = FALSE)\n  emissions &lt;- get_air_traffic_between_cities(pair[1], pair[2], air_traffic_df) * GCO2_PER_PKT / 1000000\n\n  # Ajouter les données à la liste\n  emission_by_route_list[[length(emission_by_route_list) + 1]] &lt;- list(\n    city1 = pair[1],\n    city2 = pair[2],\n    lat1 = coordinates[[1]][1],\n    lng1 = coordinates[[1]][2],\n    lat2 = coordinates[[2]][1],\n    lng2 = coordinates[[2]][2],\n    emissions = emissions\n  )\n}\n\nemission_by_route_df &lt;- dplyr::bind_rows(emission_by_route_list)\n\n\n\n\nAfficher les données\n\n\n\n\n\n\n\n\ncity1\ncity2\nlat1\nlng1\nlat2\nlng2\nemissions\n\n\n\n\nLyon\nParis\n45.74842\n4.8256735\n48.88164\n2.3561600\n17710.595\n\n\nMarseille\nParis\n43.30288\n5.3808816\n48.88164\n2.3561600\n79601.238\n\n\nLille\nParis\n50.63681\n3.0717930\n48.88164\n2.3561600\n0.000\n\n\nBordeaux\nParis\n44.82592\n-0.5559775\n48.88164\n2.3561600\n49831.726\n\n\nNantes\nParis\n47.21657\n-1.5440749\n48.88164\n2.3561600\n13398.339\n\n\nStrasbourg\nParis\n48.58449\n7.7356260\n48.88164\n2.3561600\n0.000\n\n\nMontpellier\nParis\n43.60609\n3.8827575\n48.88164\n2.3561600\n47297.213\n\n\nMarseille\nLyon\n43.30288\n5.3808816\n45.74842\n4.8256735\n0.000\n\n\nLille\nLyon\n50.63681\n3.0717930\n45.74842\n4.8256735\n0.000\n\n\nStrasbourg\nLyon\n48.58449\n7.7356260\n45.74842\n4.8256735\n0.000\n\n\nMontpellier\nLyon\n43.60609\n3.8827575\n45.74842\n4.8256735\n0.000\n\n\nToulouse\nMarseille\n43.61070\n1.4543961\n43.30288\n5.3808816\n0.000\n\n\nNice\nMarseille\n43.70479\n7.2617424\n43.30288\n5.3808816\n0.000\n\n\nMontpellier\nMarseille\n43.60609\n3.8827575\n43.30288\n5.3808816\n0.000\n\n\nBordeaux\nToulouse\n44.82592\n-0.5559775\n43.61070\n1.4543961\n0.000\n\n\nMontpellier\nToulouse\n43.60609\n3.8827575\n43.61070\n1.4543961\n0.000\n\n\nBordeaux\nLille\n44.82592\n-0.5559775\n50.63681\n3.0717930\n5412.944\n\n\nNantes\nLille\n47.21657\n-1.5440749\n50.63681\n3.0717930\n0.000\n\n\nStrasbourg\nLille\n48.58449\n7.7356260\n50.63681\n3.0717930\n0.000\n\n\nNantes\nBordeaux\n47.21657\n-1.5440749\n44.82592\n-0.5559775\n0.000\n\n\nMontpellier\nNantes\n43.60609\n3.8827575\n47.21657\n-1.5440749\n0.000\n\n\n\n\n\n\n\n\n\n\nCréer une carte de base avec le fond de carte Stadia Maps avec la fonction addTiles de leaflet\n\n\n\nCliquer pour voir la réponse\nmap &lt;- leaflet::leaflet() |&gt;\n  leaflet::addTiles(urlTemplate = TILES_URL)\n\n\n\nFaire une boucle pour ajouter toutes les lignes repérées à la carte avec la fonction addPolylines de leaflet :\n\n\nSi les émissions sont non-nulles, on les affiche en rouge avec une épaisseur de trait proportionnelle aux émissions\nSi les émissions sont nulles, on les affiche en noir en trait fin\n\n\n\nCliquer pour voir la réponse\n# Parcourir chaque ligne du dataframe\nfor (i in 1:nrow(emission_by_route_df)) {\n  # Définir les options par défaut pour les lignes\n  lat_vector &lt;- c(emission_by_route_df$lat1[i], emission_by_route_df$lat2[i])\n  lng_vector &lt;- c(emission_by_route_df$lng1[i], emission_by_route_df$lng2[i])\n  color &lt;- \"black\" # couleur par défaut\n  opacity &lt;- 0.5\n  weight &lt;- 1 # poids par défaut\n\n  # Si les émissions sont supérieures à zéro, ajuster la couleur et le poids\n  if (emission_by_route_df$emissions[i] &gt; 0) {\n    color &lt;- \"red\"\n    weight &lt;- emission_by_route_df$emissions[i] / 10000\n  }\n\n  # Ajouter des lignes à la carte\n  map &lt;- map |&gt;\n    leaflet::addPolylines(lat = lat_vector, lng = lng_vector, color = color, opacity = opacity, weight = weight)\n}\n\n\n\nFaire une boucle pour ajouter toutes les villes à la carte avec la fonction addCircleMarkers de leaflet.\n\n\n\nCliquer pour voir la réponse\n# Définir les options de label personnalisées\ncustom_label_options &lt;- leaflet::labelOptions(noHide = TRUE, style = list(\"background\" = \"rgba(255, 255, 255, 0.5)\"))\n\n# Fonction pour ajouter des marqueurs circulaires\nadd_circle_marker &lt;- function(map, lat, lng, city, label_options) {\n  map |&gt;\n    leaflet::addCircleMarkers(\n      lat = lat,\n      lng = lng,\n      radius = 5,\n      color = \"#4444AA\",\n      label = as.character(city),\n      labelOptions = label_options\n    )\n}\n\n# Boucle pour ajouter des marqueurs pour chaque ligne du dataframe\nfor (i in 1:nrow(emission_by_route_df)) {\n  map &lt;- add_circle_marker(map, emission_by_route_df$lat1[i], emission_by_route_df$lng1[i], emission_by_route_df$city1[i], custom_label_options)\n  map &lt;- add_circle_marker(map, emission_by_route_df$lat2[i], emission_by_route_df$lng2[i], emission_by_route_df$city2[i], custom_label_options)\n}\n\n\n\nAfficher la carte\n\n\n\nCliquer pour voir la réponse\nmap\n\n\n\n\n\n\n\n\n\n\nimport { button } from \"@jeremiak/download-data-button\""
  }
]